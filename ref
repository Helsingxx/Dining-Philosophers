https://www.pearsonhighered.com/assets/samplechapter/0/1/3/1/0131181637.pdf
https://www.justsoftwaresolutions.co.uk/threading/locks-mutexes-semaphores.html


// These objects are used to solve the problem of data race

// Mutex means mutual exclusion
operations:
// locking means acquiring
// releasing is unlocking
// when a thread acquires a mutex, he cannot acquire it once again and only he can release it
/!/ in the case of a binary semaphore, a thread can acquire a lock but another one can release it as well!
// acquiring a mutex succeeding ensures that it wasn't acquired before so it doesn't modify a value that was under lock (data race).
// at the same time acquiring the mutex locks the data for the current thread until it releases it.
// if a thread cannot lock, it blocks
// use mutexes only when you want to protect critical sections.


////// Semaphores mean
// to signal means to 
// to wait means to 
//
P : probehen
V : verhogen
// semaphores are for solving spinlocks, where cpu time is wasted.
// They are also used to solve when you want to allow multiple locks before a final lock and when you want to share locks!
// consumer producer problem works because it uses an array!


////// spinlocks
//


// The operations performed in waiting and signaling are atomic. That is why they are themselves protected!

// The dining philosophers problems is solved by the full algorithm, not just mutexes and semaphores, these are just parts!



EDGE CASE: Termination deadlock: If a mutex-holding task terminates for any reason, the OS can release the mutex and signal waiting tasks of this condition.